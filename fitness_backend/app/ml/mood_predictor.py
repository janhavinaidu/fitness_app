# -*- coding: utf-8 -*-
"""mood_predictor.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_OCl-9w-s04nmRN_ZR7YHCbm3j9bXsLG
"""

# JOURNALL MOOD PREDICTION




from transformers import pipeline
import re
from collections import defaultdict
from typing import Dict, Optional, List
import json
from pathlib import Path

# Load the emotion model once
emotion_model = pipeline(
    "text-classification",
    model="j-hartmann/emotion-english-distilroberta-base",
    return_all_scores=True
)

def split_into_sentences(text):
    return re.split(r'(?<=[.!?]) +', text.strip())

def preprocess_text(text):
    """Clean and preprocess text for better classification"""
    text = text.lower()
    text = re.sub(r'[^\w\s]', '', text)  # Remove punctuation
    text = re.sub(r'\s+', ' ', text).strip()  # Remove extra spaces
    return text

def predict_mood(text, confidence_threshold=0.2):
    # Split text into sentences
    sentences = split_into_sentences(text)

    # Aggregate emotion scores over sentences
    total_scores = defaultdict(float)
    for sentence in sentences:
        results = emotion_model(sentence)[0]
        for res in results:
            total_scores[res['label']] += res['score']

    # Average the scores per sentence
    avg_scores = {label: score / len(sentences) for label, score in total_scores.items()}

    # Sort by highest average score
    sorted_emotions = sorted(avg_scores.items(), key=lambda x: x[1], reverse=True)
    top_emotion, top_score = sorted_emotions[0]

    # Threshold check for confidence
    if top_score < confidence_threshold:
        top_emotion = "neutral/uncertain"



    return top_emotion, avg_scores

# Example journal entry
test_entry = """
I couldn't believe my eyes when I walked into the roomâ€”everyone was there to celebrate my birthday! It was such an unexpected and wonderful surprise.
I was completely caught off guard but so happy. Moments like these remind me how lucky I am to have such thoughtful friends.
"""

cleaned_text = preprocess_text(test_entry)
predicted_mood, scores = predict_mood(cleaned_text)

print(f"\nPredicted Mood: {predicted_mood}\n")
print("Emotion Scores:")
for emotion, score in sorted(scores.items(), key=lambda x: x[1], reverse=True):
    print(f"{emotion}: {score:.4f}")

class MoodPredictor:
    def __init__(self, model_path: Optional[str] = None):
        """Initialize mood predictor with the emotion model."""
        self.model_path = model_path
        # Initialize the emotion model
        self.emotion_model = pipeline(
            "text-classification",
            model="j-hartmann/emotion-english-distilroberta-base",
            return_all_scores=True
        )

    def split_into_sentences(self, text: str) -> List[str]:
        """Split text into sentences."""
        return re.split(r'(?<=[.!?]) +', text.strip())

    def preprocess_text(self, text: str) -> str:
        """Clean and preprocess text for better classification."""
        text = text.lower()
        text = re.sub(r'[^\w\s]', '', text)  # Remove punctuation
        text = re.sub(r'\s+', ' ', text).strip()  # Remove extra spaces
        return text

    def predict_mood(self, text: str) -> Dict:
        """
        Predict mood from input text using the emotion model.
        
        Args:
            text: str, the input text to analyze
            
        Returns:
            Dict containing mood prediction and confidence scores
        """
        try:
            # Preprocess text
            cleaned_text = self.preprocess_text(text)
            sentences = self.split_into_sentences(cleaned_text)

            # Aggregate emotion scores over sentences
            total_scores = defaultdict(float)
            for sentence in sentences:
                if sentence:  # Skip empty sentences
                    results = self.emotion_model(sentence)[0]
                    for res in results:
                        total_scores[res['label']] += res['score']

            # Average the scores per sentence
            num_sentences = len([s for s in sentences if s])  # Count non-empty sentences
            if num_sentences > 0:
                avg_scores = {label: score / num_sentences 
                            for label, score in total_scores.items()}
            else:
                # Default scores if no valid sentences
                return {
                    "predicted_mood": "neutral",
                    "confidence": 0.5,
                    "mood_scores": {
                        "joy": 0.2,
                        "neutral": 0.5,
                        "sadness": 0.15,
                        "anger": 0.05,
                        "fear": 0.05,
                        "surprise": 0.05
                    }
                }

            # Get the highest scoring emotion
            predicted_mood = max(avg_scores.items(), key=lambda x: x[1])
            
            # Map emotion model labels to our mood categories
            mood_mapping = {
                "joy": "happy",
                "sadness": "sad",
                "anger": "angry",
                "fear": "stressed",
                "surprise": "surprised",
                "neutral": "neutral"
            }

            return {
                "predicted_mood": mood_mapping.get(predicted_mood[0], "neutral"),
                "confidence": predicted_mood[1],
                "mood_scores": avg_scores
            }

        except Exception as e:
            # Fallback to simple keyword-based prediction if model fails
            return self._keyword_based_prediction(text)

    def _keyword_based_prediction(self, text: str) -> Dict:
        """Fallback method using keyword-based prediction."""
        text = text.lower()
        mood_keywords = {
            "happy": ["great", "awesome", "excellent", "good", "happy", "excited"],
            "neutral": ["okay", "fine", "alright", "normal"],
            "sad": ["bad", "tired", "exhausted", "sad", "unhappy"],
            "stressed": ["stressed", "anxious", "worried", "overwhelmed"]
        }

        mood_scores = {}
        for mood, keywords in mood_keywords.items():
            score = sum(1 for keyword in keywords if keyword in text)
            mood_scores[mood] = score

        if not any(mood_scores.values()):
            return {
                "predicted_mood": "neutral",
                "confidence": 0.5,
                "mood_scores": {
                    "happy": 0.25,
                    "neutral": 0.5,
                    "sad": 0.15,
                    "stressed": 0.1
                }
            }

        total = sum(mood_scores.values())
        if total > 0:
            for mood in mood_scores:
                mood_scores[mood] = mood_scores[mood] / total

        predicted_mood = max(mood_scores.items(), key=lambda x: x[1])[0]
        confidence = mood_scores[predicted_mood]

        return {
            "predicted_mood": predicted_mood,
            "confidence": confidence,
            "mood_scores": mood_scores
        }

    def get_mood_suggestions(self, mood: str) -> List[str]:
        """Get activity suggestions based on predicted mood."""
        suggestions = {
            "happy": [
                "Keep the momentum going with a high-energy workout!",
                "Try a new challenging exercise routine",
                "Share your positive energy in a group fitness class"
            ],
            "neutral": [
                "A moderate cardio session might boost your mood",
                "Try a balanced workout with both cardio and strength training",
                "Consider a yoga session for mind-body balance"
            ],
            "sad": [
                "A light walk in nature could help lift your spirits",
                "Try some gentle yoga or stretching",
                "Consider a short meditation session"
            ],
            "stressed": [
                "Deep breathing exercises might help reduce stress",
                "A calming yoga session could be beneficial",
                "Light stretching or walking can help clear your mind"
            ],
            "angry": [
                "Release tension with a boxing workout",
                "High-intensity interval training (HIIT)",
                "Power yoga for focused energy release"
            ],
            "surprised": [
                "Try something new like dance fitness",
                "Experiment with a different workout routine",
                "Challenge yourself with a new exercise class"
            ]
        }
        
        return suggestions.get(mood, suggestions["neutral"])

# Create a global instance
mood_predictor = MoodPredictor()

